{"ast":null,"code":"/**\n * LibHaLo - Programmatically interact with HaLo tags from the web browser, mobile application or the desktop.\n * Copyright by Arx Research, Inc., a Delaware corporation\n * License: MIT\n */\n\nconst Buffer = require('buffer/').Buffer;\nconst EC = require('elliptic').ec;\nconst ethers = require('ethers');\nconst {\n  HaloLogicError\n} = require(\"./exceptions\");\nconst BN = require('bn.js').BN;\nconst ec = new EC('secp256k1');\nfunction hex2arr(hexString) {\n  return new Uint8Array(hexString.match(/.{1,2}/g).map(byte => parseInt(byte, 16)));\n}\nfunction arr2hex(buffer) {\n  return [...new Uint8Array(buffer)].map(x => x.toString(16).padStart(2, '0')).join('');\n}\nfunction parsePublicKeys(buffer) {\n  let buf;\n  if (typeof buffer === \"string\") {\n    buf = Buffer.from(buffer, 'hex');\n  } else {\n    buf = Buffer.from(buffer);\n  }\n  let out = {};\n  let keyNo = 1;\n  while (true) {\n    let keyLength = buf[0];\n    if (typeof keyLength === \"undefined\" || keyLength === 0) {\n      break;\n    }\n    let key = buf.slice(1, 1 + keyLength);\n    out[keyNo] = key.toString('hex');\n    buf = buf.slice(1 + keyLength);\n    keyNo++;\n  }\n  return out;\n}\nfunction parseSig(res) {\n  if (res[0] !== 0x30 || res[2] !== 0x02) {\n    throw new HaloLogicError(\"Unable to parse signature, unexpected header (1).\");\n  }\n  let rLen = res[3];\n  if (res[rLen + 4] !== 0x02) {\n    throw new HaloLogicError(\"Unable to parse signature, unexpected header (2).\");\n  }\n  let sLen = res[rLen + 5];\n  if (res.length !== rLen + 4 + 2 + sLen) {\n    throw new HaloLogicError(\"Unable to parse signature, unexpected length.\");\n  }\n  let r = res.slice(4, rLen + 4);\n  let s = res.slice(rLen + 4 + 2, rLen + 4 + 2 + sLen);\n  let rn = BigInt('0x' + r.toString('hex'));\n  let sn = BigInt('0x' + s.toString('hex'));\n\n  // SECP256k1 order constant\n  let curveOrder = 115792089237316195423570985008687907852837564279074904382605163141518161494337n;\n  if (sn > curveOrder / 2n) {\n    // malleable signature, not compliant with Ethereum's EIP-2\n    // we need to flip s value in the signature\n    sn = -sn + curveOrder;\n  }\n  return {\n    r: rn.toString(16).padStart(64, '0'),\n    s: sn.toString(16).padStart(64, '0')\n  };\n}\nfunction convertSignature(digest, signature, publicKey) {\n  signature = Buffer.from(signature, \"hex\");\n  let fixedSig = parseSig(signature);\n  let recoveryParam = null;\n  for (let i = 0; i < 2; i++) {\n    if (publicKey === ec.recoverPubKey(new BN(digest, 16), fixedSig, i).encode('hex')) {\n      recoveryParam = i;\n      break;\n    }\n  }\n  if (recoveryParam === null) {\n    throw new HaloLogicError(\"Failed to get recovery param.\");\n  }\n  let finalSig = '0x' + fixedSig.r + fixedSig.s + Buffer.from([27 + recoveryParam]).toString('hex');\n  let pkeyAddress = ethers.utils.computeAddress('0x' + publicKey);\n  let recoveredAddress = ethers.utils.recoverAddress('0x' + digest, finalSig);\n  if (pkeyAddress !== recoveredAddress) {\n    throw new HaloLogicError(\"Failed to correctly recover public key from the signature.\");\n  }\n  return {\n    \"raw\": {\n      ...fixedSig,\n      v: recoveryParam + 0x1b\n    },\n    \"der\": signature.toString('hex'),\n    \"ether\": finalSig.toString('hex')\n  };\n}\nfunction recoverPublicKey(digest, signature) {\n  let out = [];\n  signature = Buffer.from(signature, \"hex\");\n  let fixedSig = parseSig(signature);\n  for (let i = 0; i < 2; i++) {\n    out.push(ec.recoverPubKey(new BN(digest, 16), fixedSig, i).encode('hex'));\n  }\n  return out;\n}\nfunction mode(arr) {\n  return arr.sort((a, b) => arr.filter(v => v === a).length - arr.filter(v => v === b).length).pop();\n}\nmodule.exports = {\n  hex2arr,\n  arr2hex,\n  parseSig,\n  convertSignature,\n  parsePublicKeys,\n  recoverPublicKey,\n  mode\n};","map":{"version":3,"names":["Buffer","require","EC","ec","ethers","HaloLogicError","BN","hex2arr","hexString","Uint8Array","match","map","byte","parseInt","arr2hex","buffer","x","toString","padStart","join","parsePublicKeys","buf","from","out","keyNo","keyLength","key","slice","parseSig","res","rLen","sLen","length","r","s","rn","BigInt","sn","curveOrder","convertSignature","digest","signature","publicKey","fixedSig","recoveryParam","i","recoverPubKey","encode","finalSig","pkeyAddress","utils","computeAddress","recoveredAddress","recoverAddress","v","recoverPublicKey","push","mode","arr","sort","a","b","filter","pop","module","exports"],"sources":["/Users/user/Desktop/Kardia/libhalo-example-reactjs/node_modules/@arx-research/libhalo/halo/utils.js"],"sourcesContent":["/**\n * LibHaLo - Programmatically interact with HaLo tags from the web browser, mobile application or the desktop.\n * Copyright by Arx Research, Inc., a Delaware corporation\n * License: MIT\n */\n\nconst Buffer = require('buffer/').Buffer;\nconst EC = require('elliptic').ec;\nconst ethers = require('ethers');\nconst {HaloLogicError} = require(\"./exceptions\");\nconst BN = require('bn.js').BN;\n\nconst ec = new EC('secp256k1');\n\nfunction hex2arr(hexString) {\n    return new Uint8Array(\n        hexString.match(/.{1,2}/g).map(\n            byte => parseInt(byte, 16)\n        )\n    );\n}\n\nfunction arr2hex(buffer) {\n    return [...new Uint8Array(buffer)]\n        .map(x => x.toString(16).padStart(2, '0'))\n        .join('');\n}\n\nfunction parsePublicKeys(buffer) {\n    let buf;\n\n    if (typeof buffer === \"string\") {\n        buf = Buffer.from(buffer, 'hex');\n    } else {\n        buf = Buffer.from(buffer);\n    }\n\n    let out = {};\n    let keyNo = 1;\n\n    while (true) {\n        let keyLength = buf[0];\n\n        if (typeof keyLength === \"undefined\" || keyLength === 0) {\n            break;\n        }\n\n        let key = buf.slice(1, 1 + keyLength);\n        out[keyNo] = key.toString('hex');\n        buf = buf.slice(1 + keyLength);\n        keyNo++;\n    }\n\n    return out;\n}\n\nfunction parseSig(res) {\n    if (res[0] !== 0x30 || res[2] !== 0x02) {\n        throw new HaloLogicError(\"Unable to parse signature, unexpected header (1).\");\n    }\n\n    let rLen = res[3];\n\n    if (res[rLen + 4] !== 0x02) {\n        throw new HaloLogicError(\"Unable to parse signature, unexpected header (2).\");\n    }\n\n    let sLen = res[rLen + 5];\n\n    if (res.length !== rLen + 4 + 2 + sLen) {\n        throw new HaloLogicError(\"Unable to parse signature, unexpected length.\");\n    }\n\n    let r = res.slice(4, rLen + 4);\n    let s = res.slice(rLen + 4 + 2, rLen + 4 + 2 + sLen);\n    let rn = BigInt('0x' + r.toString('hex'));\n    let sn = BigInt('0x' + s.toString('hex'));\n\n    // SECP256k1 order constant\n    let curveOrder = 115792089237316195423570985008687907852837564279074904382605163141518161494337n;\n\n    if (sn > curveOrder / 2n) {\n        // malleable signature, not compliant with Ethereum's EIP-2\n        // we need to flip s value in the signature\n        sn = -sn + curveOrder;\n    }\n\n    return {\n        r: rn.toString(16).padStart(64, '0'),\n        s: sn.toString(16).padStart(64, '0')\n    };\n}\n\nfunction convertSignature(digest, signature, publicKey) {\n    signature = Buffer.from(signature, \"hex\");\n    let fixedSig = parseSig(signature);\n\n    let recoveryParam = null;\n\n    for (let i = 0; i < 2; i++) {\n        if (publicKey === ec.recoverPubKey(new BN(digest, 16), fixedSig, i).encode('hex')) {\n            recoveryParam = i;\n            break;\n        }\n    }\n\n    if (recoveryParam === null) {\n        throw new HaloLogicError(\"Failed to get recovery param.\");\n    }\n\n    let finalSig = '0x' + fixedSig.r\n        + fixedSig.s\n        + Buffer.from([27 + recoveryParam]).toString('hex');\n\n    let pkeyAddress = ethers.utils.computeAddress('0x' + publicKey);\n    let recoveredAddress = ethers.utils.recoverAddress('0x' + digest, finalSig);\n\n    if (pkeyAddress !== recoveredAddress) {\n        throw new HaloLogicError(\"Failed to correctly recover public key from the signature.\");\n    }\n\n    return {\n        \"raw\": {\n            ...fixedSig,\n            v: recoveryParam + 0x1b\n        },\n        \"der\": signature.toString('hex'),\n        \"ether\": finalSig.toString('hex')\n    };\n}\n\nfunction recoverPublicKey(digest, signature) {\n    let out = [];\n\n    signature = Buffer.from(signature, \"hex\");\n    let fixedSig = parseSig(signature);\n\n    for (let i = 0; i < 2; i++) {\n        out.push(ec.recoverPubKey(new BN(digest, 16), fixedSig, i).encode('hex'));\n    }\n\n    return out;\n}\n\nfunction mode(arr) {\n    return arr.sort((a, b) =>\n        arr.filter(v => v === a).length\n        - arr.filter(v => v === b).length\n    ).pop();\n}\n\nmodule.exports = {\n    hex2arr,\n    arr2hex,\n    parseSig,\n    convertSignature,\n    parsePublicKeys,\n    recoverPublicKey,\n    mode\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}