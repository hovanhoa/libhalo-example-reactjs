{"ast":null,"code":"/**\n * WebSocket with promise api\n */\n\n/**\n * @external Channel\n */\n\nconst Channel = require('chnl');\n// todo: maybe remove PromiseController and just use promised-map with 2 items?\nconst PromiseController = require('promise-controller');\nconst {\n  PromisedMap\n} = require('promised-map');\n// todo: maybe remove Requests and just use promised-map?\nconst Requests = require('./requests');\nconst defaultOptions = require('./options');\nconst {\n  throwIf,\n  isPromise\n} = require('./utils');\n\n// see: https://developer.mozilla.org/en-US/docs/Web/API/WebSocket#Ready_state_constants\nconst STATE = {\n  CONNECTING: 0,\n  OPEN: 1,\n  CLOSING: 2,\n  CLOSED: 3\n};\n\n/**\n * @typicalname wsp\n */\nclass WebSocketAsPromised {\n  /**\n   * Constructor. Unlike original WebSocket it does not immediately open connection.\n   * Please call `open()` method to connect.\n   *\n   * @param {String} url WebSocket URL\n   * @param {Options} [options]\n   */\n  constructor(url, options) {\n    this._assertOptions(options);\n    this._url = url;\n    this._options = Object.assign({}, defaultOptions, options);\n    this._requests = new Requests();\n    this._promisedMap = new PromisedMap();\n    this._ws = null;\n    this._wsSubscription = null;\n    this._createOpeningController();\n    this._createClosingController();\n    this._createChannels();\n  }\n\n  /**\n   * Returns original WebSocket instance created by `options.createWebSocket`.\n   *\n   * @returns {WebSocket}\n   */\n  get ws() {\n    return this._ws;\n  }\n\n  /**\n   * Returns WebSocket url.\n   *\n   * @returns {String}\n   */\n  get url() {\n    return this._url;\n  }\n\n  /**\n   * Is WebSocket connection in opening state.\n   *\n   * @returns {Boolean}\n   */\n  get isOpening() {\n    return Boolean(this._ws && this._ws.readyState === STATE.CONNECTING);\n  }\n\n  /**\n   * Is WebSocket connection opened.\n   *\n   * @returns {Boolean}\n   */\n  get isOpened() {\n    return Boolean(this._ws && this._ws.readyState === STATE.OPEN);\n  }\n\n  /**\n   * Is WebSocket connection in closing state.\n   *\n   * @returns {Boolean}\n   */\n  get isClosing() {\n    return Boolean(this._ws && this._ws.readyState === STATE.CLOSING);\n  }\n\n  /**\n   * Is WebSocket connection closed.\n   *\n   * @returns {Boolean}\n   */\n  get isClosed() {\n    return Boolean(!this._ws || this._ws.readyState === STATE.CLOSED);\n  }\n\n  /**\n   * Event channel triggered when connection is opened.\n   *\n   * @see https://vitalets.github.io/chnl/#channel\n   * @example\n   * wsp.onOpen.addListener(() => console.log('Connection opened'));\n   *\n   * @returns {Channel}\n   */\n  get onOpen() {\n    return this._onOpen;\n  }\n\n  /**\n   * Event channel triggered every time when message is sent to server.\n   *\n   * @see https://vitalets.github.io/chnl/#channel\n   * @example\n   * wsp.onSend.addListener(data => console.log('Message sent', data));\n   *\n   * @returns {Channel}\n   */\n  get onSend() {\n    return this._onSend;\n  }\n\n  /**\n   * Event channel triggered every time when message received from server.\n   *\n   * @see https://vitalets.github.io/chnl/#channel\n   * @example\n   * wsp.onMessage.addListener(message => console.log(message));\n   *\n   * @returns {Channel}\n   */\n  get onMessage() {\n    return this._onMessage;\n  }\n\n  /**\n   * Event channel triggered every time when received message is successfully unpacked.\n   * For example, if you are using JSON transport, the listener will receive already JSON parsed data.\n   *\n   * @see https://vitalets.github.io/chnl/#channel\n   * @example\n   * wsp.onUnpackedMessage.addListener(data => console.log(data.foo));\n   *\n   * @returns {Channel}\n   */\n  get onUnpackedMessage() {\n    return this._onUnpackedMessage;\n  }\n\n  /**\n   * Event channel triggered every time when response to some request comes.\n   * Received message considered a response if requestId is found in it.\n   *\n   * @see https://vitalets.github.io/chnl/#channel\n   * @example\n   * wsp.onResponse.addListener(data => console.log(data));\n   *\n   * @returns {Channel}\n   */\n  get onResponse() {\n    return this._onResponse;\n  }\n\n  /**\n   * Event channel triggered when connection closed.\n   * Listener accepts single argument `{code, reason}`.\n   *\n   * @see https://vitalets.github.io/chnl/#channel\n   * @example\n   * wsp.onClose.addListener(event => console.log(`Connections closed: ${event.reason}`));\n   *\n   * @returns {Channel}\n   */\n  get onClose() {\n    return this._onClose;\n  }\n\n  /**\n   * Event channel triggered when by Websocket 'error' event.\n   *\n   * @see https://vitalets.github.io/chnl/#channel\n   * @example\n   * wsp.onError.addListener(event => console.error(event));\n   *\n   * @returns {Channel}\n   */\n  get onError() {\n    return this._onError;\n  }\n\n  /**\n   * Opens WebSocket connection. If connection already opened, promise will be resolved with \"open event\".\n   *\n   * @returns {Promise<Event>}\n   */\n  open() {\n    if (this.isClosing) {\n      return Promise.reject(new Error(`Can't open WebSocket while closing.`));\n    }\n    if (this.isOpened) {\n      return this._opening.promise;\n    }\n    return this._opening.call(() => {\n      this._opening.promise.catch(e => this._cleanup(e));\n      this._createWS();\n    });\n  }\n\n  /**\n   * Performs request and waits for response.\n   *\n   * @param {*} data\n   * @param {Object} [options]\n   * @param {String|Number} [options.requestId=<auto-generated>]\n   * @param {Number} [options.timeout=0]\n   * @returns {Promise}\n   */\n  sendRequest(data) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const requestId = options.requestId || `${Math.random()}`;\n    const timeout = options.timeout !== undefined ? options.timeout : this._options.timeout;\n    return this._requests.create(requestId, () => {\n      this._assertRequestIdHandlers();\n      const finalData = this._options.attachRequestId(data, requestId);\n      this.sendPacked(finalData);\n    }, timeout);\n  }\n\n  /**\n   * Packs data with `options.packMessage` and sends to the server.\n   *\n   * @param {*} data\n   */\n  sendPacked(data) {\n    this._assertPackingHandlers();\n    const message = this._options.packMessage(data);\n    this.send(message);\n  }\n\n  /**\n   * Sends data without packing.\n   *\n   * @param {String|Blob|ArrayBuffer} data\n   */\n  send(data) {\n    throwIf(!this.isOpened, `Can't send data because WebSocket is not opened.`);\n    this._ws.send(data);\n    this._onSend.dispatchAsync(data);\n  }\n\n  /**\n   * Waits for particular message to come.\n   *\n   * @param {Function} predicate function to check incoming message.\n   * @param {Object} [options]\n   * @param {Number} [options.timeout=0]\n   * @param {Error} [options.timeoutError]\n   * @returns {Promise}\n   *\n   * @example\n   * const response = await wsp.waitUnpackedMessage(data => data && data.foo === 'bar');\n   */\n  waitUnpackedMessage(predicate) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    throwIf(typeof predicate !== 'function', `Predicate must be a function, got ${typeof predicate}`);\n    if (options.timeout) {\n      setTimeout(() => {\n        if (this._promisedMap.has(predicate)) {\n          const error = options.timeoutError || new Error('Timeout');\n          this._promisedMap.reject(predicate, error);\n        }\n      }, options.timeout);\n    }\n    return this._promisedMap.set(predicate);\n  }\n\n  /**\n   * Closes WebSocket connection. If connection already closed, promise will be resolved with \"close event\".\n   *\n   * @param {number=} [code=1000] A numeric value indicating the status code.\n   * @param {string=} [reason] A human-readable reason for closing connection.\n   * @returns {Promise<Event>}\n   */\n  close(code, reason) {\n    // https://developer.mozilla.org/en-US/docs/Web/API/WebSocket/close\n    return this.isClosed ? Promise.resolve(this._closing.value) : this._closing.call(() => this._ws.close(code, reason));\n  }\n\n  /**\n   * Removes all listeners from WSP instance. Useful for cleanup.\n   */\n  removeAllListeners() {\n    this._onOpen.removeAllListeners();\n    this._onMessage.removeAllListeners();\n    this._onUnpackedMessage.removeAllListeners();\n    this._onResponse.removeAllListeners();\n    this._onSend.removeAllListeners();\n    this._onClose.removeAllListeners();\n    this._onError.removeAllListeners();\n  }\n  _createOpeningController() {\n    const connectionTimeout = this._options.connectionTimeout || this._options.timeout;\n    this._opening = new PromiseController({\n      timeout: connectionTimeout,\n      timeoutReason: `Can't open WebSocket within allowed timeout: ${connectionTimeout} ms.`\n    });\n  }\n  _createClosingController() {\n    const closingTimeout = this._options.timeout;\n    this._closing = new PromiseController({\n      timeout: closingTimeout,\n      timeoutReason: `Can't close WebSocket within allowed timeout: ${closingTimeout} ms.`\n    });\n  }\n  _createChannels() {\n    this._onOpen = new Channel();\n    this._onMessage = new Channel();\n    this._onUnpackedMessage = new Channel();\n    this._onResponse = new Channel();\n    this._onSend = new Channel();\n    this._onClose = new Channel();\n    this._onError = new Channel();\n  }\n  _createWS() {\n    this._ws = this._options.createWebSocket(this._url);\n    this._wsSubscription = new Channel.Subscription([{\n      channel: this._ws,\n      event: 'open',\n      listener: e => this._handleOpen(e)\n    }, {\n      channel: this._ws,\n      event: 'message',\n      listener: e => this._handleMessage(e)\n    }, {\n      channel: this._ws,\n      event: 'error',\n      listener: e => this._handleError(e)\n    }, {\n      channel: this._ws,\n      event: 'close',\n      listener: e => this._handleClose(e)\n    }]).on();\n  }\n  _handleOpen(event) {\n    this._onOpen.dispatchAsync(event);\n    this._opening.resolve(event);\n  }\n  _handleMessage(event) {\n    const data = this._options.extractMessageData(event);\n    this._onMessage.dispatchAsync(data);\n    this._tryUnpack(data);\n  }\n  _tryUnpack(data) {\n    if (this._options.unpackMessage) {\n      data = this._options.unpackMessage(data);\n      if (isPromise(data)) {\n        data.then(data => this._handleUnpackedData(data));\n      } else {\n        this._handleUnpackedData(data);\n      }\n    }\n  }\n  _handleUnpackedData(data) {\n    if (data !== undefined) {\n      // todo: maybe trigger onUnpackedMessage always?\n      this._onUnpackedMessage.dispatchAsync(data);\n      this._tryHandleResponse(data);\n    }\n    this._tryHandleWaitingMessage(data);\n  }\n  _tryHandleResponse(data) {\n    if (this._options.extractRequestId) {\n      const requestId = this._options.extractRequestId(data);\n      if (requestId) {\n        this._onResponse.dispatchAsync(data, requestId);\n        this._requests.resolve(requestId, data);\n      }\n    }\n  }\n  _tryHandleWaitingMessage(data) {\n    this._promisedMap.forEach((_, predicate) => {\n      let isMatched = false;\n      try {\n        isMatched = predicate(data);\n      } catch (e) {\n        this._promisedMap.reject(predicate, e);\n        return;\n      }\n      if (isMatched) {\n        this._promisedMap.resolve(predicate, data);\n      }\n    });\n  }\n  _handleError(event) {\n    this._onError.dispatchAsync(event);\n  }\n  _handleClose(event) {\n    this._onClose.dispatchAsync(event);\n    this._closing.resolve(event);\n    const error = new Error(`WebSocket closed with reason: ${event.reason} (${event.code}).`);\n    if (this._opening.isPending) {\n      this._opening.reject(error);\n    }\n    this._cleanup(error);\n  }\n  _cleanupWS() {\n    if (this._wsSubscription) {\n      this._wsSubscription.off();\n      this._wsSubscription = null;\n    }\n    this._ws = null;\n  }\n  _cleanup(error) {\n    this._cleanupWS();\n    this._requests.rejectAll(error);\n  }\n  _assertOptions(options) {\n    Object.keys(options || {}).forEach(key => {\n      if (!defaultOptions.hasOwnProperty(key)) {\n        throw new Error(`Unknown option: ${key}`);\n      }\n    });\n  }\n  _assertPackingHandlers() {\n    const {\n      packMessage,\n      unpackMessage\n    } = this._options;\n    throwIf(!packMessage || !unpackMessage, `Please define 'options.packMessage / options.unpackMessage' for sending packed messages.`);\n  }\n  _assertRequestIdHandlers() {\n    const {\n      attachRequestId,\n      extractRequestId\n    } = this._options;\n    throwIf(!attachRequestId || !extractRequestId, `Please define 'options.attachRequestId / options.extractRequestId' for sending requests.`);\n  }\n}\nmodule.exports = WebSocketAsPromised;","map":{"version":3,"names":["Channel","require","PromiseController","PromisedMap","Requests","defaultOptions","throwIf","isPromise","STATE","CONNECTING","OPEN","CLOSING","CLOSED","WebSocketAsPromised","constructor","url","options","_assertOptions","_url","_options","Object","assign","_requests","_promisedMap","_ws","_wsSubscription","_createOpeningController","_createClosingController","_createChannels","ws","isOpening","Boolean","readyState","isOpened","isClosing","isClosed","onOpen","_onOpen","onSend","_onSend","onMessage","_onMessage","onUnpackedMessage","_onUnpackedMessage","onResponse","_onResponse","onClose","_onClose","onError","_onError","open","Promise","reject","Error","_opening","promise","call","catch","e","_cleanup","_createWS","sendRequest","data","arguments","length","undefined","requestId","Math","random","timeout","create","_assertRequestIdHandlers","finalData","attachRequestId","sendPacked","_assertPackingHandlers","message","packMessage","send","dispatchAsync","waitUnpackedMessage","predicate","setTimeout","has","error","timeoutError","set","close","code","reason","resolve","_closing","value","removeAllListeners","connectionTimeout","timeoutReason","closingTimeout","createWebSocket","Subscription","channel","event","listener","_handleOpen","_handleMessage","_handleError","_handleClose","on","extractMessageData","_tryUnpack","unpackMessage","then","_handleUnpackedData","_tryHandleResponse","_tryHandleWaitingMessage","extractRequestId","forEach","_","isMatched","isPending","_cleanupWS","off","rejectAll","keys","key","hasOwnProperty","module","exports"],"sources":["/Users/user/Desktop/Kardia/libhalo-example-reactjs/node_modules/websocket-as-promised/src/index.js"],"sourcesContent":["/**\n * WebSocket with promise api\n */\n\n/**\n * @external Channel\n */\n\nconst Channel = require('chnl');\n// todo: maybe remove PromiseController and just use promised-map with 2 items?\nconst PromiseController = require('promise-controller');\nconst { PromisedMap } = require('promised-map');\n// todo: maybe remove Requests and just use promised-map?\nconst Requests = require('./requests');\nconst defaultOptions = require('./options');\nconst {throwIf, isPromise} = require('./utils');\n\n// see: https://developer.mozilla.org/en-US/docs/Web/API/WebSocket#Ready_state_constants\nconst STATE = {\n  CONNECTING: 0,\n  OPEN: 1,\n  CLOSING: 2,\n  CLOSED: 3,\n};\n\n/**\n * @typicalname wsp\n */\nclass WebSocketAsPromised {\n  /**\n   * Constructor. Unlike original WebSocket it does not immediately open connection.\n   * Please call `open()` method to connect.\n   *\n   * @param {String} url WebSocket URL\n   * @param {Options} [options]\n   */\n  constructor(url, options) {\n    this._assertOptions(options);\n    this._url = url;\n    this._options = Object.assign({}, defaultOptions, options);\n    this._requests = new Requests();\n    this._promisedMap = new PromisedMap();\n    this._ws = null;\n    this._wsSubscription = null;\n    this._createOpeningController();\n    this._createClosingController();\n    this._createChannels();\n  }\n\n  /**\n   * Returns original WebSocket instance created by `options.createWebSocket`.\n   *\n   * @returns {WebSocket}\n   */\n  get ws() {\n    return this._ws;\n  }\n\n  /**\n   * Returns WebSocket url.\n   *\n   * @returns {String}\n   */\n  get url() {\n    return this._url;\n  }\n\n  /**\n   * Is WebSocket connection in opening state.\n   *\n   * @returns {Boolean}\n   */\n  get isOpening() {\n    return Boolean(this._ws && this._ws.readyState === STATE.CONNECTING);\n  }\n\n  /**\n   * Is WebSocket connection opened.\n   *\n   * @returns {Boolean}\n   */\n  get isOpened() {\n    return Boolean(this._ws && this._ws.readyState === STATE.OPEN);\n  }\n\n  /**\n   * Is WebSocket connection in closing state.\n   *\n   * @returns {Boolean}\n   */\n  get isClosing() {\n    return Boolean(this._ws && this._ws.readyState === STATE.CLOSING);\n  }\n\n  /**\n   * Is WebSocket connection closed.\n   *\n   * @returns {Boolean}\n   */\n  get isClosed() {\n    return Boolean(!this._ws || this._ws.readyState === STATE.CLOSED);\n  }\n\n  /**\n   * Event channel triggered when connection is opened.\n   *\n   * @see https://vitalets.github.io/chnl/#channel\n   * @example\n   * wsp.onOpen.addListener(() => console.log('Connection opened'));\n   *\n   * @returns {Channel}\n   */\n  get onOpen() {\n    return this._onOpen;\n  }\n\n  /**\n   * Event channel triggered every time when message is sent to server.\n   *\n   * @see https://vitalets.github.io/chnl/#channel\n   * @example\n   * wsp.onSend.addListener(data => console.log('Message sent', data));\n   *\n   * @returns {Channel}\n   */\n  get onSend() {\n    return this._onSend;\n  }\n\n  /**\n   * Event channel triggered every time when message received from server.\n   *\n   * @see https://vitalets.github.io/chnl/#channel\n   * @example\n   * wsp.onMessage.addListener(message => console.log(message));\n   *\n   * @returns {Channel}\n   */\n  get onMessage() {\n    return this._onMessage;\n  }\n\n  /**\n   * Event channel triggered every time when received message is successfully unpacked.\n   * For example, if you are using JSON transport, the listener will receive already JSON parsed data.\n   *\n   * @see https://vitalets.github.io/chnl/#channel\n   * @example\n   * wsp.onUnpackedMessage.addListener(data => console.log(data.foo));\n   *\n   * @returns {Channel}\n   */\n  get onUnpackedMessage() {\n    return this._onUnpackedMessage;\n  }\n\n  /**\n   * Event channel triggered every time when response to some request comes.\n   * Received message considered a response if requestId is found in it.\n   *\n   * @see https://vitalets.github.io/chnl/#channel\n   * @example\n   * wsp.onResponse.addListener(data => console.log(data));\n   *\n   * @returns {Channel}\n   */\n  get onResponse() {\n    return this._onResponse;\n  }\n\n  /**\n   * Event channel triggered when connection closed.\n   * Listener accepts single argument `{code, reason}`.\n   *\n   * @see https://vitalets.github.io/chnl/#channel\n   * @example\n   * wsp.onClose.addListener(event => console.log(`Connections closed: ${event.reason}`));\n   *\n   * @returns {Channel}\n   */\n  get onClose() {\n    return this._onClose;\n  }\n\n  /**\n   * Event channel triggered when by Websocket 'error' event.\n   *\n   * @see https://vitalets.github.io/chnl/#channel\n   * @example\n   * wsp.onError.addListener(event => console.error(event));\n   *\n   * @returns {Channel}\n   */\n  get onError() {\n    return this._onError;\n  }\n\n  /**\n   * Opens WebSocket connection. If connection already opened, promise will be resolved with \"open event\".\n   *\n   * @returns {Promise<Event>}\n   */\n  open() {\n    if (this.isClosing) {\n      return Promise.reject(new Error(`Can't open WebSocket while closing.`));\n    }\n    if (this.isOpened) {\n      return this._opening.promise;\n    }\n    return this._opening.call(() => {\n      this._opening.promise.catch(e => this._cleanup(e));\n      this._createWS();\n    });\n  }\n\n  /**\n   * Performs request and waits for response.\n   *\n   * @param {*} data\n   * @param {Object} [options]\n   * @param {String|Number} [options.requestId=<auto-generated>]\n   * @param {Number} [options.timeout=0]\n   * @returns {Promise}\n   */\n  sendRequest(data, options = {}) {\n    const requestId = options.requestId || `${Math.random()}`;\n    const timeout = options.timeout !== undefined ? options.timeout : this._options.timeout;\n    return this._requests.create(requestId, () => {\n      this._assertRequestIdHandlers();\n      const finalData = this._options.attachRequestId(data, requestId);\n      this.sendPacked(finalData);\n    }, timeout);\n  }\n\n  /**\n   * Packs data with `options.packMessage` and sends to the server.\n   *\n   * @param {*} data\n   */\n  sendPacked(data) {\n    this._assertPackingHandlers();\n    const message = this._options.packMessage(data);\n    this.send(message);\n  }\n\n  /**\n   * Sends data without packing.\n   *\n   * @param {String|Blob|ArrayBuffer} data\n   */\n  send(data) {\n    throwIf(!this.isOpened, `Can't send data because WebSocket is not opened.`);\n    this._ws.send(data);\n    this._onSend.dispatchAsync(data);\n  }\n\n  /**\n   * Waits for particular message to come.\n   *\n   * @param {Function} predicate function to check incoming message.\n   * @param {Object} [options]\n   * @param {Number} [options.timeout=0]\n   * @param {Error} [options.timeoutError]\n   * @returns {Promise}\n   *\n   * @example\n   * const response = await wsp.waitUnpackedMessage(data => data && data.foo === 'bar');\n   */\n  waitUnpackedMessage(predicate, options = {}) {\n    throwIf(typeof predicate !== 'function', `Predicate must be a function, got ${typeof predicate}`);\n    if (options.timeout) {\n      setTimeout(() => {\n        if (this._promisedMap.has(predicate)) {\n          const error = options.timeoutError || new Error('Timeout');\n          this._promisedMap.reject(predicate, error);\n        }\n      }, options.timeout);\n    }\n    return this._promisedMap.set(predicate);\n  }\n\n  /**\n   * Closes WebSocket connection. If connection already closed, promise will be resolved with \"close event\".\n   *\n   * @param {number=} [code=1000] A numeric value indicating the status code.\n   * @param {string=} [reason] A human-readable reason for closing connection.\n   * @returns {Promise<Event>}\n   */\n  close(code, reason) { // https://developer.mozilla.org/en-US/docs/Web/API/WebSocket/close\n    return this.isClosed\n      ? Promise.resolve(this._closing.value)\n      : this._closing.call(() => this._ws.close(code, reason));\n  }\n\n  /**\n   * Removes all listeners from WSP instance. Useful for cleanup.\n   */\n  removeAllListeners() {\n    this._onOpen.removeAllListeners();\n    this._onMessage.removeAllListeners();\n    this._onUnpackedMessage.removeAllListeners();\n    this._onResponse.removeAllListeners();\n    this._onSend.removeAllListeners();\n    this._onClose.removeAllListeners();\n    this._onError.removeAllListeners();\n  }\n\n  _createOpeningController() {\n    const connectionTimeout = this._options.connectionTimeout || this._options.timeout;\n    this._opening = new PromiseController({\n      timeout: connectionTimeout,\n      timeoutReason: `Can't open WebSocket within allowed timeout: ${connectionTimeout} ms.`\n    });\n  }\n\n  _createClosingController() {\n    const closingTimeout = this._options.timeout;\n    this._closing = new PromiseController({\n      timeout: closingTimeout,\n      timeoutReason: `Can't close WebSocket within allowed timeout: ${closingTimeout} ms.`\n    });\n  }\n\n  _createChannels() {\n    this._onOpen = new Channel();\n    this._onMessage = new Channel();\n    this._onUnpackedMessage = new Channel();\n    this._onResponse = new Channel();\n    this._onSend = new Channel();\n    this._onClose = new Channel();\n    this._onError = new Channel();\n  }\n\n  _createWS() {\n    this._ws = this._options.createWebSocket(this._url);\n    this._wsSubscription = new Channel.Subscription([\n      { channel: this._ws, event: 'open', listener: e => this._handleOpen(e) },\n      { channel: this._ws, event: 'message', listener: e => this._handleMessage(e) },\n      { channel: this._ws, event: 'error', listener: e => this._handleError(e) },\n      { channel: this._ws, event: 'close', listener: e => this._handleClose(e) },\n    ]).on();\n  }\n\n  _handleOpen(event) {\n    this._onOpen.dispatchAsync(event);\n    this._opening.resolve(event);\n  }\n\n  _handleMessage(event) {\n    const data = this._options.extractMessageData(event);\n    this._onMessage.dispatchAsync(data);\n    this._tryUnpack(data);\n  }\n\n  _tryUnpack(data) {\n    if (this._options.unpackMessage) {\n      data = this._options.unpackMessage(data);\n      if (isPromise(data)) {\n        data.then(data => this._handleUnpackedData(data));\n      } else {\n        this._handleUnpackedData(data);\n      }\n    }\n  }\n\n  _handleUnpackedData(data) {\n    if (data !== undefined) {\n      // todo: maybe trigger onUnpackedMessage always?\n      this._onUnpackedMessage.dispatchAsync(data);\n      this._tryHandleResponse(data);\n    }\n    this._tryHandleWaitingMessage(data);\n  }\n\n  _tryHandleResponse(data) {\n    if (this._options.extractRequestId) {\n      const requestId = this._options.extractRequestId(data);\n      if (requestId) {\n        this._onResponse.dispatchAsync(data, requestId);\n        this._requests.resolve(requestId, data);\n      }\n    }\n  }\n\n  _tryHandleWaitingMessage(data) {\n    this._promisedMap.forEach((_, predicate) => {\n      let isMatched = false;\n      try {\n        isMatched = predicate(data);\n      } catch (e) {\n        this._promisedMap.reject(predicate, e);\n        return;\n      }\n      if (isMatched) {\n        this._promisedMap.resolve(predicate, data);\n      }\n    });\n  }\n\n  _handleError(event) {\n    this._onError.dispatchAsync(event);\n  }\n\n  _handleClose(event) {\n    this._onClose.dispatchAsync(event);\n    this._closing.resolve(event);\n    const error = new Error(`WebSocket closed with reason: ${event.reason} (${event.code}).`);\n    if (this._opening.isPending) {\n      this._opening.reject(error);\n    }\n    this._cleanup(error);\n  }\n\n  _cleanupWS() {\n    if (this._wsSubscription) {\n      this._wsSubscription.off();\n      this._wsSubscription = null;\n    }\n    this._ws = null;\n  }\n\n  _cleanup(error) {\n    this._cleanupWS();\n    this._requests.rejectAll(error);\n  }\n\n  _assertOptions(options) {\n    Object.keys(options || {}).forEach(key => {\n      if (!defaultOptions.hasOwnProperty(key)) {\n        throw new Error(`Unknown option: ${key}`);\n      }\n    });\n  }\n\n  _assertPackingHandlers() {\n    const { packMessage, unpackMessage } = this._options;\n    throwIf(!packMessage || !unpackMessage,\n      `Please define 'options.packMessage / options.unpackMessage' for sending packed messages.`\n    );\n  }\n\n  _assertRequestIdHandlers() {\n    const { attachRequestId, extractRequestId } = this._options;\n    throwIf(!attachRequestId || !extractRequestId,\n      `Please define 'options.attachRequestId / options.extractRequestId' for sending requests.`\n    );\n  }\n}\n\nmodule.exports = WebSocketAsPromised;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}