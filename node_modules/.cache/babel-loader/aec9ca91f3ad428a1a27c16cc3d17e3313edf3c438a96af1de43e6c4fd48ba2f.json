{"ast":null,"code":"/**\n * @ignore\n */\nconst defaults = require('./defaults');\nconst {\n  isPromise,\n  createErrorType,\n  tryCall\n} = require('./utils');\n\n/**\n * @typicalname pc\n */\nclass PromiseController {\n  /**\n   * Creates promise controller. Unlike original Promise, it does not immediately call any function.\n   * Instead it has [.call()](#PromiseController+call) method that calls provided function\n   * and stores `resolve / reject` methods for future access.\n   *\n   * @param {Options} [options]\n   */\n  constructor(options) {\n    this._options = Object.assign({}, defaults, options);\n    this._resolve = null;\n    this._reject = null;\n    this._isPending = false;\n    this._isFulfilled = false;\n    this._isRejected = false;\n    this._value = undefined;\n    this._promise = null;\n    this._timer = null;\n  }\n\n  /**\n   * Returns promise itself.\n   *\n   * @returns {Promise}\n   */\n  get promise() {\n    return this._promise;\n  }\n\n  /**\n   * Returns value with that promise was settled (fulfilled or rejected).\n   *\n   * @returns {*}\n   */\n  get value() {\n    return this._value;\n  }\n\n  /**\n   * Returns true if promise is pending.\n   *\n   * @returns {Boolean}\n   */\n  get isPending() {\n    return this._isPending;\n  }\n\n  /**\n   * Returns true if promise is fulfilled.\n   *\n   * @returns {Boolean}\n   */\n  get isFulfilled() {\n    return this._isFulfilled;\n  }\n\n  /**\n   * Returns true if promise rejected.\n   *\n   * @returns {Boolean}\n   */\n  get isRejected() {\n    return this._isRejected;\n  }\n\n  /**\n   * Returns true if promise is fulfilled or rejected.\n   *\n   * @returns {Boolean}\n   */\n  get isSettled() {\n    return this._isFulfilled || this._isRejected;\n  }\n\n  /**\n   * Calls `fn` and returns promise OR just returns existing promise from previous `call()` if it is still pending.\n   * To fulfill returned promise you should use\n   * {@link PromiseController#resolve} / {@link PromiseController#reject} methods.\n   * If `fn` itself returns promise, then external promise is attached to it and fulfills together.\n   * If no `fn` passed - promiseController is initialized as well.\n   *\n   * @param {Function} [fn] function to be called.\n   * @returns {Promise}\n   */\n  call(fn) {\n    if (!this._isPending) {\n      this.reset();\n      this._createPromise();\n      this._createTimer();\n      this._callFn(fn);\n    }\n    return this._promise;\n  }\n\n  /**\n   * Resolves pending promise with specified `value`.\n   *\n   * @param {*} [value]\n   */\n  resolve(value) {\n    if (this._isPending) {\n      if (isPromise(value)) {\n        this._tryAttachToPromise(value);\n      } else {\n        this._settle(value);\n        this._isFulfilled = true;\n        this._resolve(value);\n      }\n    }\n  }\n\n  /**\n   * Rejects pending promise with specified `value`.\n   *\n   * @param {*} [value]\n   */\n  reject(value) {\n    if (this._isPending) {\n      this._settle(value);\n      this._isRejected = true;\n      this._reject(value);\n    }\n  }\n\n  /**\n   * Resets to initial state.\n   * If promise is pending it will be rejected with {@link PromiseController.ResetError}.\n   */\n  reset() {\n    if (this._isPending) {\n      const message = tryCall(this._options.resetReason);\n      const error = new PromiseController.ResetError(message);\n      this.reject(error);\n    }\n    this._promise = null;\n    this._isPending = false;\n    this._isFulfilled = false;\n    this._isRejected = false;\n    this._value = undefined;\n    this._clearTimer();\n  }\n\n  /**\n   * Re-assign one or more options.\n   *\n   * @param {Options} options\n   */\n  configure(options) {\n    Object.assign(this._options, options);\n  }\n  _createPromise() {\n    this._promise = new Promise((resolve, reject) => {\n      this._isPending = true;\n      this._resolve = resolve;\n      this._reject = reject;\n    });\n  }\n  _handleTimeout() {\n    const messageTpl = tryCall(this._options.timeoutReason);\n    const message = typeof messageTpl === 'string' ? messageTpl.replace('{timeout}', this._options.timeout) : '';\n    const error = new PromiseController.TimeoutError(message);\n    this.reject(error);\n  }\n  _createTimer() {\n    if (this._options.timeout) {\n      this._timer = setTimeout(() => this._handleTimeout(), this._options.timeout);\n    }\n  }\n  _clearTimer() {\n    if (this._timer) {\n      clearTimeout(this._timer);\n      this._timer = null;\n    }\n  }\n  _settle(value) {\n    this._isPending = false;\n    this._value = value;\n    this._clearTimer();\n  }\n  _callFn(fn) {\n    if (typeof fn === 'function') {\n      try {\n        const result = fn();\n        this._tryAttachToPromise(result);\n      } catch (e) {\n        this.reject(e);\n      }\n    }\n  }\n  _tryAttachToPromise(p) {\n    if (isPromise(p)) {\n      p.then(value => this.resolve(value), e => this.reject(e));\n    }\n  }\n}\n\n/**\n * Error for rejection in case of timeout.\n * @type {PromiseController.TimeoutError}\n */\nPromiseController.TimeoutError = createErrorType('TimeoutError');\n\n/**\n * Error for rejection in case of call `.reset()` while promise is pending.\n * @type {PromiseController.ResetError}\n */\nPromiseController.ResetError = createErrorType('ResetError');\nmodule.exports = PromiseController;","map":{"version":3,"names":["defaults","require","isPromise","createErrorType","tryCall","PromiseController","constructor","options","_options","Object","assign","_resolve","_reject","_isPending","_isFulfilled","_isRejected","_value","undefined","_promise","_timer","promise","value","isPending","isFulfilled","isRejected","isSettled","call","fn","reset","_createPromise","_createTimer","_callFn","resolve","_tryAttachToPromise","_settle","reject","message","resetReason","error","ResetError","_clearTimer","configure","Promise","_handleTimeout","messageTpl","timeoutReason","replace","timeout","TimeoutError","setTimeout","clearTimeout","result","e","p","then","module","exports"],"sources":["/Users/user/Desktop/Kardia/libhalo-example-reactjs/node_modules/promise-controller/src/index.js"],"sourcesContent":["/**\n * @ignore\n */\nconst defaults = require('./defaults');\nconst {isPromise, createErrorType, tryCall} = require('./utils');\n\n/**\n * @typicalname pc\n */\nclass PromiseController {\n  /**\n   * Creates promise controller. Unlike original Promise, it does not immediately call any function.\n   * Instead it has [.call()](#PromiseController+call) method that calls provided function\n   * and stores `resolve / reject` methods for future access.\n   *\n   * @param {Options} [options]\n   */\n  constructor(options) {\n    this._options = Object.assign({}, defaults, options);\n    this._resolve = null;\n    this._reject = null;\n    this._isPending = false;\n    this._isFulfilled = false;\n    this._isRejected = false;\n    this._value = undefined;\n    this._promise = null;\n    this._timer = null;\n  }\n\n  /**\n   * Returns promise itself.\n   *\n   * @returns {Promise}\n   */\n  get promise() {\n    return this._promise;\n  }\n\n  /**\n   * Returns value with that promise was settled (fulfilled or rejected).\n   *\n   * @returns {*}\n   */\n  get value() {\n    return this._value;\n  }\n\n  /**\n   * Returns true if promise is pending.\n   *\n   * @returns {Boolean}\n   */\n  get isPending() {\n    return this._isPending;\n  }\n\n  /**\n   * Returns true if promise is fulfilled.\n   *\n   * @returns {Boolean}\n   */\n  get isFulfilled() {\n    return this._isFulfilled;\n  }\n\n  /**\n   * Returns true if promise rejected.\n   *\n   * @returns {Boolean}\n   */\n  get isRejected() {\n    return this._isRejected;\n  }\n\n  /**\n   * Returns true if promise is fulfilled or rejected.\n   *\n   * @returns {Boolean}\n   */\n  get isSettled() {\n    return this._isFulfilled || this._isRejected;\n  }\n\n  /**\n   * Calls `fn` and returns promise OR just returns existing promise from previous `call()` if it is still pending.\n   * To fulfill returned promise you should use\n   * {@link PromiseController#resolve} / {@link PromiseController#reject} methods.\n   * If `fn` itself returns promise, then external promise is attached to it and fulfills together.\n   * If no `fn` passed - promiseController is initialized as well.\n   *\n   * @param {Function} [fn] function to be called.\n   * @returns {Promise}\n   */\n  call(fn) {\n    if (!this._isPending) {\n      this.reset();\n      this._createPromise();\n      this._createTimer();\n      this._callFn(fn);\n    }\n    return this._promise;\n  }\n\n  /**\n   * Resolves pending promise with specified `value`.\n   *\n   * @param {*} [value]\n   */\n  resolve(value) {\n    if (this._isPending) {\n      if (isPromise(value)) {\n        this._tryAttachToPromise(value);\n      } else {\n        this._settle(value);\n        this._isFulfilled = true;\n        this._resolve(value);\n      }\n    }\n  }\n\n  /**\n   * Rejects pending promise with specified `value`.\n   *\n   * @param {*} [value]\n   */\n  reject(value) {\n    if (this._isPending) {\n      this._settle(value);\n      this._isRejected = true;\n      this._reject(value);\n    }\n  }\n\n  /**\n   * Resets to initial state.\n   * If promise is pending it will be rejected with {@link PromiseController.ResetError}.\n   */\n  reset() {\n    if (this._isPending) {\n      const message = tryCall(this._options.resetReason);\n      const error = new PromiseController.ResetError(message);\n      this.reject(error);\n    }\n    this._promise = null;\n    this._isPending = false;\n    this._isFulfilled = false;\n    this._isRejected = false;\n    this._value = undefined;\n    this._clearTimer();\n  }\n\n  /**\n   * Re-assign one or more options.\n   *\n   * @param {Options} options\n   */\n  configure(options) {\n    Object.assign(this._options, options);\n  }\n\n  _createPromise() {\n    this._promise = new Promise((resolve, reject) => {\n      this._isPending = true;\n      this._resolve = resolve;\n      this._reject = reject;\n    });\n  }\n\n  _handleTimeout() {\n    const messageTpl = tryCall(this._options.timeoutReason);\n    const message = typeof messageTpl === 'string' ? messageTpl.replace('{timeout}', this._options.timeout) : '';\n    const error = new PromiseController.TimeoutError(message);\n    this.reject(error);\n  }\n\n  _createTimer() {\n    if (this._options.timeout) {\n      this._timer = setTimeout(() => this._handleTimeout(), this._options.timeout);\n    }\n  }\n\n  _clearTimer() {\n    if (this._timer) {\n      clearTimeout(this._timer);\n      this._timer = null;\n    }\n  }\n\n  _settle(value) {\n    this._isPending = false;\n    this._value = value;\n    this._clearTimer();\n  }\n\n  _callFn(fn) {\n    if (typeof fn === 'function') {\n      try {\n        const result = fn();\n        this._tryAttachToPromise(result);\n      } catch (e) {\n        this.reject(e);\n      }\n    }\n  }\n\n  _tryAttachToPromise(p) {\n    if (isPromise(p)) {\n      p.then(value => this.resolve(value), e => this.reject(e));\n    }\n  }\n}\n\n/**\n * Error for rejection in case of timeout.\n * @type {PromiseController.TimeoutError}\n */\nPromiseController.TimeoutError = createErrorType('TimeoutError');\n\n/**\n * Error for rejection in case of call `.reset()` while promise is pending.\n * @type {PromiseController.ResetError}\n */\nPromiseController.ResetError = createErrorType('ResetError');\n\nmodule.exports = PromiseController;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}