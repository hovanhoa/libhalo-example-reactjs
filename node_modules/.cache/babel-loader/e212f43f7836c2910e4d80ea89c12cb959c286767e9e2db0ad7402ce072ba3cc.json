{"ast":null,"code":"const WebSocketAsPromised = require('websocket-as-promised');\nfunction haloCreateWs(url) {\n  return new WebSocketAsPromised(url, {\n    packMessage: data => JSON.stringify(data),\n    unpackMessage: data => JSON.parse(data),\n    attachRequestId: (data, requestId) => Object.assign({\n      uid: requestId\n    }, data),\n    extractRequestId: data => data && data.uid\n  });\n}\nfunction runHealthCheck(url, openTimeout) {\n  return new Promise((resolve, reject) => {\n    let closeTimeout = null;\n    const pingUrl = url.includes('?') ? url + '&ping=1' : url + '?ping=1';\n    const wsp = new WebSocketAsPromised(pingUrl, {\n      timeout: openTimeout\n    });\n    wsp.onClose.addListener(event => {\n      if (event.code === 4090) {\n        if (closeTimeout) {\n          clearTimeout(closeTimeout);\n        }\n        resolve(url);\n      } else {\n        reject(new Error(\"Unexpected WebSocket close code: \" + event.code));\n      }\n    });\n    wsp.open().then(() => {\n      closeTimeout = setTimeout(() => {\n        wsp.close();\n        reject(new Error('WebSocket didn\\'t close as expected.'));\n      }, 2000);\n    }).catch(err => {\n      reject(err);\n    });\n  });\n}\nfunction createChecks(wsPort, wssPort) {\n  // detect Firefox\n  const isFirefox = window.hasOwnProperty(\"InternalError\");\n  const openTimeout = isFirefox ? 10000 : 5000;\n  let checks = [runHealthCheck('ws://127.0.0.1:' + wsPort + '/ws', openTimeout)];\n  if (!isFirefox) {\n    // It seems like Firefox is processing one WebSocket request at time.\n    // A call to wss:// endpoint with incorrect certificate could hang the request\n    // for many seconds until it actually fails, and this would hang all remaining WS requests too.\n    // We need to skip this check on Firefox to avoid race conditions and have reasonable performance.\n    checks.push(runHealthCheck('wss://halo-bridge.internal:' + wssPort + '/ws', openTimeout));\n  }\n  return checks;\n}\nasync function haloFindBridge(options) {\n  options = Object.assign({}, options) || {};\n  if (!options.wsPort) {\n    options.wsPort = 32868;\n  }\n  if (!options.wssPort) {\n    options.wssPort = 32869;\n  }\n  const wsPort = options.wsPort;\n  const wssPort = options.wssPort;\n  if (options.diagnose) {\n    let res = await Promise.allSettled(createChecks(wsPort, wssPort));\n    let urls = [];\n    let errors = [];\n    for (let o of res) {\n      if (o.status === \"fulfilled\") {\n        urls.push(o.value);\n      } else {\n        errors.push(o.reason);\n      }\n    }\n    return {\n      urls,\n      errors\n    };\n  } else {\n    try {\n      return await Promise.any(createChecks(wsPort, wssPort));\n    } catch (e) {\n      throw new Error(\"Unable to locate halo bridge.\");\n    }\n  }\n}\nmodule.exports = {\n  haloCreateWs,\n  haloFindBridge\n};","map":{"version":3,"names":["WebSocketAsPromised","require","haloCreateWs","url","packMessage","data","JSON","stringify","unpackMessage","parse","attachRequestId","requestId","Object","assign","uid","extractRequestId","runHealthCheck","openTimeout","Promise","resolve","reject","closeTimeout","pingUrl","includes","wsp","timeout","onClose","addListener","event","code","clearTimeout","Error","open","then","setTimeout","close","catch","err","createChecks","wsPort","wssPort","isFirefox","window","hasOwnProperty","checks","push","haloFindBridge","options","diagnose","res","allSettled","urls","errors","o","status","value","reason","any","e","module","exports"],"sources":["/Users/user/Desktop/Kardia/libhalo-example-reactjs/src/libhalo/web/web_utils.js"],"sourcesContent":["const WebSocketAsPromised = require('websocket-as-promised');\n\nfunction haloCreateWs(url) {\n    return new WebSocketAsPromised(url, {\n        packMessage: data => JSON.stringify(data),\n        unpackMessage: data => JSON.parse(data),\n        attachRequestId: (data, requestId) => Object.assign({uid: requestId}, data),\n        extractRequestId: data => data && data.uid\n    });\n}\n\nfunction runHealthCheck(url, openTimeout) {\n    return new Promise((resolve, reject) => {\n        let closeTimeout = null;\n\n        const pingUrl = url.includes('?') ? (url + '&ping=1') : (url + '?ping=1');\n        const wsp = new WebSocketAsPromised(pingUrl, {timeout: openTimeout});\n\n        wsp.onClose.addListener(event => {\n            if (event.code === 4090) {\n                if (closeTimeout) {\n                    clearTimeout(closeTimeout);\n                }\n\n                resolve(url);\n            } else {\n                reject(new Error(\"Unexpected WebSocket close code: \" + event.code));\n            }\n        });\n\n        wsp.open()\n            .then(() => {\n                closeTimeout = setTimeout(() => {\n                    wsp.close();\n                    reject(new Error('WebSocket didn\\'t close as expected.'));\n                }, 2000);\n            })\n            .catch((err) => {\n                reject(err);\n            })\n    });\n}\n\nfunction createChecks(wsPort, wssPort) {\n    // detect Firefox\n    const isFirefox = window.hasOwnProperty(\"InternalError\");\n    const openTimeout = isFirefox ? 10000 : 5000;\n\n    let checks = [\n        runHealthCheck('ws://127.0.0.1:' + wsPort + '/ws', openTimeout)\n    ];\n\n    if (!isFirefox) {\n        // It seems like Firefox is processing one WebSocket request at time.\n        // A call to wss:// endpoint with incorrect certificate could hang the request\n        // for many seconds until it actually fails, and this would hang all remaining WS requests too.\n        // We need to skip this check on Firefox to avoid race conditions and have reasonable performance.\n        checks.push(runHealthCheck('wss://halo-bridge.internal:' + wssPort + '/ws', openTimeout));\n    }\n\n    return checks;\n}\n\nasync function haloFindBridge(options) {\n    options = Object.assign({}, options) || {};\n\n    if (!options.wsPort) {\n        options.wsPort = 32868;\n    }\n\n    if (!options.wssPort) {\n        options.wssPort = 32869;\n    }\n\n    const wsPort = options.wsPort;\n    const wssPort = options.wssPort;\n\n    if (options.diagnose) {\n        let res = await Promise.allSettled(createChecks(wsPort, wssPort));\n        let urls = [];\n        let errors = [];\n\n        for (let o of res) {\n            if (o.status === \"fulfilled\") {\n                urls.push(o.value);\n            } else {\n                errors.push(o.reason);\n            }\n        }\n\n        return {\n            urls,\n            errors\n        };\n    } else {\n        try {\n            return await Promise.any(createChecks(wsPort, wssPort));\n        } catch (e) {\n            throw new Error(\"Unable to locate halo bridge.\");\n        }\n    }\n}\n\nmodule.exports = {haloCreateWs, haloFindBridge};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}