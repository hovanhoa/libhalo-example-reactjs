{"ast":null,"code":"const {\n  NFCAbortedError,\n  NFCMethodNotSupported\n} = require(\"../halo/exceptions\");\nconst {\n  execCredential\n} = require(\"./credential\");\nconst {\n  execWebNFC\n} = require(\"./webnfc\");\nconst {\n  execHaloCmd\n} = require(\"./common\");\nlet isCallRunning = null;\nfunction makeDefault(curValue, defaultValue) {\n  if (typeof curValue === \"undefined\") {\n    return defaultValue;\n  }\n  if (curValue === null) {\n    return defaultValue;\n  }\n  return curValue;\n}\n\n/**\n * Detect the best command execution method for the current device.\n * @returns {string} Either \"credential\" or \"webnfc\".\n */\nfunction detectMethod() {\n  try {\n    new NDEFReader();\n  } catch (e) {\n    // WebNFC not supported\n    return \"credential\";\n  }\n  return \"webnfc\";\n}\n\n/**\n * Execute the NFC command from the web browser.\n * @param command Command specification object.\n * @param options Additional options for the command executor.\n * @returns {Promise<*>} Command execution result.\n */\nasync function execHaloCmdWeb(command, options) {\n  if (options && !options.noDebounce && isCallRunning) {\n    throw new NFCAbortedError(\"The operation was debounced.\");\n  }\n  isCallRunning = true;\n  options = options ? Object.assign({}, options) : {};\n  options.method = makeDefault(options.method, detectMethod());\n  options.noDebounce = makeDefault(options.noDebounce, false);\n  options.compatibleCallMode = makeDefault(options.compatibleCallMode, true);\n  command = command ? Object.assign({}, command) : {};\n  try {\n    let cmdOpts = {};\n    if (options.method === \"credential\") {\n      cmdOpts = {\n        method: \"credential\",\n        exec: async command => await execCredential(command, {\n          debugCallback: options.debugCallback,\n          statusCallback: options.statusCallback,\n          compatibleCallMode: options.compatibleCallMode\n        })\n      };\n    } else if (options.method === \"webnfc\") {\n      cmdOpts = {\n        method: \"webnfc\",\n        exec: async command => await execWebNFC(command, {\n          debugCallback: options.debugCallback,\n          statusCallback: options.statusCallback\n        })\n      };\n    } else {\n      throw new NFCMethodNotSupported(\"Unsupported options.method parameter specified.\");\n    }\n    return await execHaloCmd(command, cmdOpts);\n  } finally {\n    isCallRunning = false;\n  }\n}\nmodule.exports = {\n  execHaloCmdWeb,\n  detectMethod\n};","map":{"version":3,"names":["NFCAbortedError","NFCMethodNotSupported","require","execCredential","execWebNFC","execHaloCmd","isCallRunning","makeDefault","curValue","defaultValue","detectMethod","NDEFReader","e","execHaloCmdWeb","command","options","noDebounce","Object","assign","method","compatibleCallMode","cmdOpts","exec","debugCallback","statusCallback","module","exports"],"sources":["/Users/user/Desktop/Kardia/libhalo-example-reactjs/src/libhalo/drivers/web.js"],"sourcesContent":["const {NFCAbortedError, NFCMethodNotSupported} = require(\"../halo/exceptions\");\nconst {execCredential} = require(\"./credential\");\nconst {execWebNFC} = require(\"./webnfc\");\nconst {execHaloCmd} = require(\"./common\");\n\nlet isCallRunning = null;\n\nfunction makeDefault(curValue, defaultValue) {\n    if (typeof curValue === \"undefined\") {\n        return defaultValue;\n    }\n\n    if (curValue === null) {\n        return defaultValue;\n    }\n\n    return curValue;\n}\n\n/**\n * Detect the best command execution method for the current device.\n * @returns {string} Either \"credential\" or \"webnfc\".\n */\nfunction detectMethod() {\n    try {\n        new NDEFReader();\n    } catch (e) {\n        // WebNFC not supported\n        return \"credential\";\n    }\n\n    return \"webnfc\";\n}\n\n/**\n * Execute the NFC command from the web browser.\n * @param command Command specification object.\n * @param options Additional options for the command executor.\n * @returns {Promise<*>} Command execution result.\n */\nasync function execHaloCmdWeb(command, options) {\n    if (options && !options.noDebounce && isCallRunning) {\n        throw new NFCAbortedError(\"The operation was debounced.\");\n    }\n\n    isCallRunning = true;\n\n    options = options ? Object.assign({}, options) : {};\n    options.method = makeDefault(options.method, detectMethod());\n    options.noDebounce = makeDefault(options.noDebounce, false);\n    options.compatibleCallMode = makeDefault(options.compatibleCallMode, true);\n\n    command = command ? Object.assign({}, command) : {};\n\n    try {\n        let cmdOpts = {};\n\n        if (options.method === \"credential\") {\n            cmdOpts = {\n                method: \"credential\",\n                exec: async (command) => await execCredential(command, {\n                    debugCallback: options.debugCallback,\n                    statusCallback: options.statusCallback,\n                    compatibleCallMode: options.compatibleCallMode\n                })\n            };\n        } else if (options.method === \"webnfc\") {\n            cmdOpts = {\n                method: \"webnfc\",\n                exec: async (command) => await execWebNFC(command, {\n                    debugCallback: options.debugCallback,\n                    statusCallback: options.statusCallback\n                })\n            };\n        } else {\n            throw new NFCMethodNotSupported(\"Unsupported options.method parameter specified.\");\n        }\n\n        return await execHaloCmd(command, cmdOpts);\n    } finally {\n        isCallRunning = false;\n    }\n}\n\nmodule.exports = {\n    execHaloCmdWeb,\n    detectMethod\n};\n"],"mappings":"AAAA,MAAM;EAACA,eAAe;EAAEC;AAAqB,CAAC,GAAGC,OAAO,CAAC,oBAAoB,CAAC;AAC9E,MAAM;EAACC;AAAc,CAAC,GAAGD,OAAO,CAAC,cAAc,CAAC;AAChD,MAAM;EAACE;AAAU,CAAC,GAAGF,OAAO,CAAC,UAAU,CAAC;AACxC,MAAM;EAACG;AAAW,CAAC,GAAGH,OAAO,CAAC,UAAU,CAAC;AAEzC,IAAII,aAAa,GAAG,IAAI;AAExB,SAASC,WAAWA,CAACC,QAAQ,EAAEC,YAAY,EAAE;EACzC,IAAI,OAAOD,QAAQ,KAAK,WAAW,EAAE;IACjC,OAAOC,YAAY;EACvB;EAEA,IAAID,QAAQ,KAAK,IAAI,EAAE;IACnB,OAAOC,YAAY;EACvB;EAEA,OAAOD,QAAQ;AACnB;;AAEA;AACA;AACA;AACA;AACA,SAASE,YAAYA,CAAA,EAAG;EACpB,IAAI;IACA,IAAIC,UAAU,CAAC,CAAC;EACpB,CAAC,CAAC,OAAOC,CAAC,EAAE;IACR;IACA,OAAO,YAAY;EACvB;EAEA,OAAO,QAAQ;AACnB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,eAAeC,cAAcA,CAACC,OAAO,EAAEC,OAAO,EAAE;EAC5C,IAAIA,OAAO,IAAI,CAACA,OAAO,CAACC,UAAU,IAAIV,aAAa,EAAE;IACjD,MAAM,IAAIN,eAAe,CAAC,8BAA8B,CAAC;EAC7D;EAEAM,aAAa,GAAG,IAAI;EAEpBS,OAAO,GAAGA,OAAO,GAAGE,MAAM,CAACC,MAAM,CAAC,CAAC,CAAC,EAAEH,OAAO,CAAC,GAAG,CAAC,CAAC;EACnDA,OAAO,CAACI,MAAM,GAAGZ,WAAW,CAACQ,OAAO,CAACI,MAAM,EAAET,YAAY,CAAC,CAAC,CAAC;EAC5DK,OAAO,CAACC,UAAU,GAAGT,WAAW,CAACQ,OAAO,CAACC,UAAU,EAAE,KAAK,CAAC;EAC3DD,OAAO,CAACK,kBAAkB,GAAGb,WAAW,CAACQ,OAAO,CAACK,kBAAkB,EAAE,IAAI,CAAC;EAE1EN,OAAO,GAAGA,OAAO,GAAGG,MAAM,CAACC,MAAM,CAAC,CAAC,CAAC,EAAEJ,OAAO,CAAC,GAAG,CAAC,CAAC;EAEnD,IAAI;IACA,IAAIO,OAAO,GAAG,CAAC,CAAC;IAEhB,IAAIN,OAAO,CAACI,MAAM,KAAK,YAAY,EAAE;MACjCE,OAAO,GAAG;QACNF,MAAM,EAAE,YAAY;QACpBG,IAAI,EAAE,MAAOR,OAAO,IAAK,MAAMX,cAAc,CAACW,OAAO,EAAE;UACnDS,aAAa,EAAER,OAAO,CAACQ,aAAa;UACpCC,cAAc,EAAET,OAAO,CAACS,cAAc;UACtCJ,kBAAkB,EAAEL,OAAO,CAACK;QAChC,CAAC;MACL,CAAC;IACL,CAAC,MAAM,IAAIL,OAAO,CAACI,MAAM,KAAK,QAAQ,EAAE;MACpCE,OAAO,GAAG;QACNF,MAAM,EAAE,QAAQ;QAChBG,IAAI,EAAE,MAAOR,OAAO,IAAK,MAAMV,UAAU,CAACU,OAAO,EAAE;UAC/CS,aAAa,EAAER,OAAO,CAACQ,aAAa;UACpCC,cAAc,EAAET,OAAO,CAACS;QAC5B,CAAC;MACL,CAAC;IACL,CAAC,MAAM;MACH,MAAM,IAAIvB,qBAAqB,CAAC,iDAAiD,CAAC;IACtF;IAEA,OAAO,MAAMI,WAAW,CAACS,OAAO,EAAEO,OAAO,CAAC;EAC9C,CAAC,SAAS;IACNf,aAAa,GAAG,KAAK;EACzB;AACJ;AAEAmB,MAAM,CAACC,OAAO,GAAG;EACbb,cAAc;EACdH;AACJ,CAAC"},"metadata":{},"sourceType":"module","externalDependencies":[]}