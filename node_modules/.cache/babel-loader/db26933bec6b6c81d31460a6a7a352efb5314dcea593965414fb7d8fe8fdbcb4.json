{"ast":null,"code":"/**\n * LibHaLo - Programmatically interact with HaLo tags from the web browser, mobile application or the desktop.\n * Copyright by Arx Research, Inc., a Delaware corporation\n * License: MIT\n */\n\nconst Buffer = require('buffer/').Buffer;\nconst ethers = require('ethers');\nconst {\n  HaloLogicError,\n  HaloTagError\n} = require(\"./exceptions\");\nconst {\n  convertSignature,\n  mode,\n  parseSig,\n  parsePublicKeys\n} = require(\"./utils\");\nconst {\n  FLAGS\n} = require(\"./flags\");\nconst {\n  sha256\n} = require(\"js-sha256\");\nconst EC = require(\"elliptic\").ec;\nconst CMD = require('./cmdcodes').CMD_CODES;\nconst ec = new EC('secp256k1');\n\n/**\n * NOTE: Since LibHaLo supports multiple driver backends which differ in their implementation and behavior,\n * there are few things to consider when implementing a new command or modifying the existing code.\n *\n * Web-based drivers (webnfc, credential):\n * -> the command implementation may only call options.exec() once;\n *\n * React Native driver (nfc-manager) and PC/SC driver (pcsc):\n * -> there are no limitations on the number of calls to options.exec();\n *\n * The command could provide a different implementation for a given driver, but that should be\n * a last-resort solution. Optimally, the command implementation should be independent of the driver used,\n * if that's possible.\n */\n\nfunction extractPublicKeyWebNFC(keyNo, resp) {\n  let publicKey = null;\n  let pkKey = \"pk\" + keyNo;\n  if (resp.extra.hasOwnProperty(pkKey)) {\n    publicKey = Buffer.from(resp.extra[pkKey], \"hex\");\n  } else if (resp.extra.hasOwnProperty(\"static\")) {\n    let pkeys = parsePublicKeys(Buffer.from(resp.extra[\"static\"], \"hex\"));\n    publicKey = pkeys[keyNo];\n  }\n  return publicKey;\n}\nasync function cmdGetPkeys(options, args) {\n  let payload = Buffer.concat([Buffer.from([CMD.SHARED_CMD_GET_PKEYS])]);\n  let resp = await options.exec(payload);\n  let res = Buffer.from(resp.result, \"hex\");\n  return {\n    \"publicKeys\": parsePublicKeys(res)\n  };\n}\nasync function cmdSign(options, args) {\n  let checks = [args.hasOwnProperty(\"digest\") && typeof args.digest !== \"undefined\", args.hasOwnProperty(\"message\") && typeof args.message !== \"undefined\", args.hasOwnProperty(\"typedData\") && typeof args.typedData !== \"undefined\"];\n  let numDataArgs = checks.filter(x => !!x).length;\n  if (numDataArgs !== 1) {\n    throw new HaloLogicError(\"One of the following arguments are required: digest, message, typedData.\");\n  }\n  let messageBuf = null;\n  let digestBuf = null;\n  if (args.hasOwnProperty(\"message\") && typeof args.message !== \"undefined\") {\n    if (args.format === \"text\") {\n      messageBuf = Buffer.from(args.message);\n    } else if (!args.format || args.format === \"hex\") {\n      messageBuf = Buffer.from(args.message, \"hex\");\n    } else {\n      throw new HaloLogicError(\"Invalid message format specified. Valid formats: text, hex.\");\n    }\n    digestBuf = Buffer.from(ethers.utils.hashMessage(messageBuf).slice(2), \"hex\");\n  } else if (args.hasOwnProperty(\"typedData\") && typeof args.typedData !== \"undefined\") {\n    let hashStr;\n    try {\n      hashStr = ethers.utils._TypedDataEncoder.hash(args.typedData.domain, args.typedData.types, args.typedData.value);\n    } catch (e) {\n      throw new HaloLogicError(\"Unable to encode typed data. Please check if the data provided conforms to the required schema.\");\n    }\n    digestBuf = Buffer.from(hashStr.slice(2), \"hex\");\n  } else if (args.hasOwnProperty(\"digest\") && typeof args.digest !== \"undefined\") {\n    digestBuf = Buffer.from(args.digest, \"hex\");\n  } else {\n    throw new HaloLogicError(\"Either args.digest, args.message or args.typedData is required.\");\n  }\n  let payload;\n  if (args.legacySignCommand || options.method === \"webnfc\") {\n    // the public key will be available through URL parameters\n    // we only need to sign the digest\n    payload = Buffer.concat([Buffer.from([CMD.SHARED_CMD_SIGN, args.keyNo]), digestBuf]);\n  } else {\n    // sign the digest and also fetch the public key\n    payload = Buffer.concat([Buffer.from([CMD.SHARED_CMD_FETCH_SIGN, args.keyNo]), digestBuf]);\n  }\n  let resp;\n  try {\n    resp = await options.exec(payload);\n  } catch (e) {\n    if (e instanceof HaloTagError) {\n      if (e.name === \"ERROR_CODE_UNKNOWN_CMD\") {\n        throw new HaloLogicError(\"The tag doesn't support the new signing command. Please set command.legacySignCommand = true.\");\n      }\n    }\n    throw e;\n  }\n  let sigBuf = Buffer.from(resp.result, \"hex\");\n  let sigLen = sigBuf[1] + 2;\n  let sig = sigBuf.slice(0, sigLen).toString('hex');\n  let publicKey = null;\n  if (!args.legacySignCommand && options.method !== \"webnfc\") {\n    if (sigBuf[sigLen] !== 0x04) {\n      throw new HaloLogicError(\"Assertion failed, expected public key first byte to be 0x04.\");\n    }\n    publicKey = sigBuf.slice(sigLen, sigLen + 65);\n  } else if (options.method === \"webnfc\") {\n    publicKey = extractPublicKeyWebNFC(args.keyNo, resp);\n  }\n  let inputObj = {\n    \"keyNo\": args.keyNo,\n    \"digest\": digestBuf.toString('hex')\n  };\n  if (messageBuf !== null) {\n    inputObj.message = messageBuf.toString('hex');\n  } else if (args.typedData) {\n    inputObj.typedData = args.typedData;\n    inputObj.primaryType = ethers.utils._TypedDataEncoder.getPrimaryType(args.typedData.types);\n    inputObj.domainHash = ethers.utils._TypedDataEncoder.hashDomain(args.typedData.domain).slice(2);\n  }\n  if (publicKey) {\n    return {\n      \"input\": inputObj,\n      \"signature\": convertSignature(digestBuf.toString('hex'), sig.toString('hex'), publicKey.toString('hex')),\n      publicKey: publicKey.toString('hex')\n    };\n  } else {\n    return {\n      \"input\": inputObj,\n      \"signature\": {\n        \"der\": sig.toString('hex')\n      }\n    };\n  }\n}\nasync function cmdWriteLatch(options, args) {\n  let payload = Buffer.concat([Buffer.from([CMD.SHARED_CMD_LATCH_DATA, args.latchNo]), Buffer.from(args.data, \"hex\")]);\n  await options.exec(payload);\n  return {\n    \"status\": \"ok\"\n  };\n}\nasync function cmdSignRandom(options, args) {\n  let resp = await options.exec(Buffer.from([CMD.SHARED_CMD_SIGN_RANDOM, args.keyNo]));\n  let resBuf = Buffer.from(resp.result, 'hex');\n  let digest = resBuf.slice(0, 32);\n  let signature = resBuf.slice(32, 32 + resBuf[33] + 2);\n  let publicKey = resBuf.slice(32 + resBuf[33] + 2);\n  let counter = digest.readUInt32BE(0);\n  return {\n    \"counter\": counter,\n    \"digest\": digest.toString('hex'),\n    \"signature\": signature.toString('hex'),\n    \"publicKey\": publicKey.toString('hex')\n  };\n}\nasync function cmdSignChallenge(options, args) {\n  let challengeBuf = Buffer.from(args.challenge, \"hex\");\n  let resp = await options.exec(Buffer.from([CMD.SHARED_CMD_SIGN_CHALLENGE, args.keyNo, ...challengeBuf]));\n  let resBuf = Buffer.from(resp.result, 'hex');\n  let sigLen = 2 + resBuf[1];\n  let signature = resBuf.slice(0, sigLen);\n  let publicKey = resBuf.slice(sigLen);\n  return {\n    \"signature\": signature.toString('hex'),\n    \"publicKey\": publicKey.toString('hex')\n  };\n}\nasync function cmdCfgNDEF(options, args) {\n  if (args.flagHidePk1 && args.flagHidePk2) {\n    throw new HaloLogicError(\"It's not allowed to use both flagHidePk1 and flagHidePk2.\");\n  }\n  let flagBuf = Buffer.alloc(2);\n  Object.keys(args).filter(k => k.startsWith('flag') && args[k]).map(k => FLAGS[k]).forEach(v => {\n    flagBuf[v[0]] |= v[1];\n  });\n  let payload = Buffer.concat([Buffer.from([CMD.SHARED_CMD_SET_NDEF_MODE]), flagBuf]);\n  await options.exec(payload);\n  return {\n    \"status\": \"ok\"\n  };\n}\nasync function cmdGenKey(options, args) {\n  if (!args.entropy) {\n    let payload = Buffer.concat([Buffer.from([CMD.SHARED_CMD_GENERATE_3RD_KEY])]);\n    let resp = await options.exec(payload);\n    let res = Buffer.from(resp.result, \"hex\");\n    return {\n      \"status\": \"ok\",\n      \"publicKey\": res.toString('hex'),\n      \"needsConfirm\": false\n    };\n  } else {\n    let entropyBuf = Buffer.from(args.entropy, \"hex\");\n    if (entropyBuf.length !== 32) {\n      throw new HaloLogicError(\"The command.entropy should be exactly 32 bytes, hex encoded.\");\n    }\n    let payload = Buffer.concat([Buffer.from([CMD.SHARED_CMD_GENERATE_3RD_KEY]), entropyBuf]);\n    let resp;\n    try {\n      resp = await options.exec(payload);\n    } catch (e) {\n      if (e instanceof HaloTagError) {\n        if (e.name === \"ERROR_CODE_INVALID_LENGTH\") {\n          throw new HaloLogicError(\"The hardened key generation algorithm is not supported with this tag version.\");\n        }\n      }\n      throw e;\n    }\n    let res = Buffer.from(resp.result, \"hex\");\n    if (res.length === 65) {\n      throw new HaloLogicError(\"The hardened key generation algorithm is not supported with this tag version.\");\n    }\n    let msg1 = Buffer.from(sha256(res.slice(0, 32)), 'hex');\n    let msg2 = Buffer.from(sha256(res.slice(32, 64)), 'hex');\n    let sig = res.slice(64);\n    let sig1Length = sig[1];\n    let sig1 = sig.slice(0, 2 + sig1Length);\n    let sig2 = sig.slice(2 + sig1Length);\n    let candidates = [];\n    for (let i = 0; i < 2; i++) {\n      candidates.push(ec.recoverPubKey(msg1, parseSig(sig1), i).encode('hex'));\n      candidates.push(ec.recoverPubKey(msg2, parseSig(sig2), i).encode('hex'));\n    }\n    let bestPk = Buffer.from(mode(candidates), 'hex');\n    return {\n      \"status\": \"ok\",\n      \"publicKey\": bestPk.toString('hex'),\n      \"needsConfirm\": true\n    };\n  }\n}\nasync function cmdGenKeyConfirm(options, args) {\n  let payload = Buffer.concat([Buffer.from([CMD.SHARED_CMD_GENERATE_3RD_KEY_CONT]), Buffer.from(args.publicKey, \"hex\")]);\n  await options.exec(payload);\n  return {\n    \"status\": \"ok\"\n  };\n}\nasync function cmdGenKeyFinalize(options, args) {\n  let payload = Buffer.concat([Buffer.from([CMD.SHARED_CMD_GENERATE_3RD_KEY_FINALIZE])]);\n  await options.exec(payload);\n  return {\n    \"status\": \"ok\"\n  };\n}\nmodule.exports = {\n  cmdSign,\n  cmdSignRandom,\n  cmdWriteLatch,\n  cmdCfgNDEF,\n  cmdGenKey,\n  cmdGenKeyConfirm,\n  cmdGetPkeys,\n  cmdGenKeyFinalize,\n  cmdSignChallenge\n};","map":{"version":3,"names":["Buffer","require","ethers","HaloLogicError","HaloTagError","convertSignature","mode","parseSig","parsePublicKeys","FLAGS","sha256","EC","ec","CMD","CMD_CODES","extractPublicKeyWebNFC","keyNo","resp","publicKey","pkKey","extra","hasOwnProperty","from","pkeys","cmdGetPkeys","options","args","payload","concat","SHARED_CMD_GET_PKEYS","exec","res","result","cmdSign","checks","digest","message","typedData","numDataArgs","filter","x","length","messageBuf","digestBuf","format","utils","hashMessage","slice","hashStr","_TypedDataEncoder","hash","domain","types","value","e","legacySignCommand","method","SHARED_CMD_SIGN","SHARED_CMD_FETCH_SIGN","name","sigBuf","sigLen","sig","toString","inputObj","primaryType","getPrimaryType","domainHash","hashDomain","cmdWriteLatch","SHARED_CMD_LATCH_DATA","latchNo","data","cmdSignRandom","SHARED_CMD_SIGN_RANDOM","resBuf","signature","counter","readUInt32BE","cmdSignChallenge","challengeBuf","challenge","SHARED_CMD_SIGN_CHALLENGE","cmdCfgNDEF","flagHidePk1","flagHidePk2","flagBuf","alloc","Object","keys","k","startsWith","map","forEach","v","SHARED_CMD_SET_NDEF_MODE","cmdGenKey","entropy","SHARED_CMD_GENERATE_3RD_KEY","entropyBuf","msg1","msg2","sig1Length","sig1","sig2","candidates","i","push","recoverPubKey","encode","bestPk","cmdGenKeyConfirm","SHARED_CMD_GENERATE_3RD_KEY_CONT","cmdGenKeyFinalize","SHARED_CMD_GENERATE_3RD_KEY_FINALIZE","module","exports"],"sources":["/Users/user/Desktop/Kardia/libhalo-example-reactjs/node_modules/@arx-research/libhalo/halo/commands.js"],"sourcesContent":["/**\n * LibHaLo - Programmatically interact with HaLo tags from the web browser, mobile application or the desktop.\n * Copyright by Arx Research, Inc., a Delaware corporation\n * License: MIT\n */\n\nconst Buffer = require('buffer/').Buffer;\nconst ethers = require('ethers');\nconst {HaloLogicError, HaloTagError} = require(\"./exceptions\");\nconst {convertSignature, mode, parseSig, parsePublicKeys} = require(\"./utils\");\nconst {FLAGS} = require(\"./flags\");\nconst {sha256} = require(\"js-sha256\");\nconst EC = require(\"elliptic\").ec;\nconst CMD = require('./cmdcodes').CMD_CODES;\n\nconst ec = new EC('secp256k1');\n\n/**\n * NOTE: Since LibHaLo supports multiple driver backends which differ in their implementation and behavior,\n * there are few things to consider when implementing a new command or modifying the existing code.\n *\n * Web-based drivers (webnfc, credential):\n * -> the command implementation may only call options.exec() once;\n *\n * React Native driver (nfc-manager) and PC/SC driver (pcsc):\n * -> there are no limitations on the number of calls to options.exec();\n *\n * The command could provide a different implementation for a given driver, but that should be\n * a last-resort solution. Optimally, the command implementation should be independent of the driver used,\n * if that's possible.\n */\n\nfunction extractPublicKeyWebNFC(keyNo, resp) {\n    let publicKey = null;\n    let pkKey = \"pk\" + keyNo;\n\n    if (resp.extra.hasOwnProperty(pkKey)) {\n        publicKey = Buffer.from(resp.extra[pkKey], \"hex\");\n    } else if (resp.extra.hasOwnProperty(\"static\")) {\n        let pkeys = parsePublicKeys(Buffer.from(resp.extra[\"static\"], \"hex\"));\n        publicKey = pkeys[keyNo];\n    }\n\n    return publicKey;\n}\n\nasync function cmdGetPkeys(options, args) {\n    let payload = Buffer.concat([\n        Buffer.from([CMD.SHARED_CMD_GET_PKEYS])\n    ]);\n\n    let resp = await options.exec(payload);\n    let res = Buffer.from(resp.result, \"hex\");\n\n    return {\"publicKeys\": parsePublicKeys(res)};\n}\n\nasync function cmdSign(options, args) {\n    let checks = [\n        args.hasOwnProperty(\"digest\") && typeof args.digest !== \"undefined\",\n        args.hasOwnProperty(\"message\") && typeof args.message !== \"undefined\",\n        args.hasOwnProperty(\"typedData\") && typeof args.typedData !== \"undefined\"\n    ];\n\n    let numDataArgs = checks.filter((x) => !!x).length;\n\n    if (numDataArgs !== 1) {\n        throw new HaloLogicError(\"One of the following arguments are required: digest, message, typedData.\");\n    }\n\n    let messageBuf = null;\n    let digestBuf = null;\n\n    if (args.hasOwnProperty(\"message\") && typeof args.message !== \"undefined\") {\n        if (args.format === \"text\") {\n            messageBuf = Buffer.from(args.message);\n        } else if (!args.format || args.format === \"hex\") {\n            messageBuf = Buffer.from(args.message, \"hex\");\n        } else {\n            throw new HaloLogicError(\"Invalid message format specified. Valid formats: text, hex.\");\n        }\n\n        digestBuf = Buffer.from(ethers.utils.hashMessage(messageBuf).slice(2), \"hex\");\n    } else if (args.hasOwnProperty(\"typedData\") && typeof args.typedData !== \"undefined\") {\n        let hashStr;\n\n        try {\n            hashStr = ethers.utils._TypedDataEncoder.hash(args.typedData.domain, args.typedData.types, args.typedData.value);\n        } catch (e) {\n            throw new HaloLogicError(\"Unable to encode typed data. Please check if the data provided conforms to the required schema.\");\n        }\n\n        digestBuf = Buffer.from(hashStr.slice(2), \"hex\");\n    } else if (args.hasOwnProperty(\"digest\") && typeof args.digest !== \"undefined\") {\n        digestBuf = Buffer.from(args.digest, \"hex\");\n    } else {\n        throw new HaloLogicError(\"Either args.digest, args.message or args.typedData is required.\");\n    }\n\n    let payload;\n\n    if (args.legacySignCommand || options.method === \"webnfc\") {\n        // the public key will be available through URL parameters\n        // we only need to sign the digest\n        payload = Buffer.concat([\n            Buffer.from([CMD.SHARED_CMD_SIGN, args.keyNo]),\n            digestBuf\n        ]);\n    } else {\n        // sign the digest and also fetch the public key\n        payload = Buffer.concat([\n            Buffer.from([CMD.SHARED_CMD_FETCH_SIGN, args.keyNo]),\n            digestBuf\n        ]);\n    }\n\n    let resp;\n\n    try {\n        resp = await options.exec(payload);\n    } catch (e) {\n        if (e instanceof HaloTagError) {\n            if (e.name === \"ERROR_CODE_UNKNOWN_CMD\") {\n                throw new HaloLogicError(\"The tag doesn't support the new signing command. Please set command.legacySignCommand = true.\");\n            }\n        }\n\n        throw e;\n    }\n\n    let sigBuf = Buffer.from(resp.result, \"hex\");\n    let sigLen = sigBuf[1] + 2;\n    let sig = sigBuf.slice(0, sigLen).toString('hex');\n    let publicKey = null;\n\n    if (!args.legacySignCommand && options.method !== \"webnfc\") {\n        if (sigBuf[sigLen] !== 0x04) {\n            throw new HaloLogicError(\"Assertion failed, expected public key first byte to be 0x04.\");\n        }\n\n        publicKey = sigBuf.slice(sigLen, sigLen + 65);\n    } else if (options.method === \"webnfc\") {\n        publicKey = extractPublicKeyWebNFC(args.keyNo, resp);\n    }\n\n    let inputObj = {\n        \"keyNo\": args.keyNo,\n        \"digest\": digestBuf.toString('hex'),\n    };\n\n    if (messageBuf !== null) {\n        inputObj.message = messageBuf.toString('hex');\n    } else if (args.typedData) {\n        inputObj.typedData = args.typedData;\n\n        inputObj.primaryType = ethers.utils._TypedDataEncoder.getPrimaryType(args.typedData.types);\n        inputObj.domainHash = ethers.utils._TypedDataEncoder.hashDomain(args.typedData.domain).slice(2);\n    }\n\n    if (publicKey) {\n        return {\n            \"input\": inputObj,\n            \"signature\": convertSignature(digestBuf.toString('hex'), sig.toString('hex'), publicKey.toString('hex')),\n            publicKey: publicKey.toString('hex')\n        };\n    } else {\n        return {\n            \"input\": inputObj,\n            \"signature\": {\n                \"der\": sig.toString('hex')\n            }\n        };\n    }\n}\n\nasync function cmdWriteLatch(options, args) {\n    let payload = Buffer.concat([\n        Buffer.from([CMD.SHARED_CMD_LATCH_DATA, args.latchNo]),\n        Buffer.from(args.data, \"hex\")\n    ]);\n\n    await options.exec(payload);\n    return {\"status\": \"ok\"};\n}\n\nasync function cmdSignRandom(options, args) {\n    let resp = await options.exec(Buffer.from([CMD.SHARED_CMD_SIGN_RANDOM, args.keyNo]));\n\n    let resBuf = Buffer.from(resp.result, 'hex');\n    let digest = resBuf.slice(0, 32);\n    let signature = resBuf.slice(32, 32 + resBuf[33] + 2);\n    let publicKey = resBuf.slice(32 + resBuf[33] + 2);\n\n    let counter = digest.readUInt32BE(0);\n\n    return {\n        \"counter\": counter,\n        \"digest\": digest.toString('hex'),\n        \"signature\": signature.toString('hex'),\n        \"publicKey\": publicKey.toString('hex')\n    };\n}\n\nasync function cmdSignChallenge(options, args) {\n    let challengeBuf = Buffer.from(args.challenge, \"hex\");\n    let resp = await options.exec(Buffer.from([CMD.SHARED_CMD_SIGN_CHALLENGE, args.keyNo, ...challengeBuf]));\n\n    let resBuf = Buffer.from(resp.result, 'hex');\n    let sigLen = 2 + resBuf[1];\n\n    let signature = resBuf.slice(0, sigLen);\n    let publicKey = resBuf.slice(sigLen);\n\n    return {\n        \"signature\": signature.toString('hex'),\n        \"publicKey\": publicKey.toString('hex')\n    };\n}\n\nasync function cmdCfgNDEF(options, args) {\n    if (args.flagHidePk1 && args.flagHidePk2) {\n        throw new HaloLogicError(\"It's not allowed to use both flagHidePk1 and flagHidePk2.\");\n    }\n\n    let flagBuf = Buffer.alloc(2);\n\n    Object.keys(args)\n        .filter((k) => k.startsWith('flag') && args[k])\n        .map((k) => FLAGS[k])\n        .forEach((v) => {\n            flagBuf[v[0]] |= v[1];\n        });\n\n    let payload = Buffer.concat([\n        Buffer.from([CMD.SHARED_CMD_SET_NDEF_MODE]),\n        flagBuf\n    ]);\n    await options.exec(payload);\n\n    return {\"status\": \"ok\"};\n}\n\nasync function cmdGenKey(options, args) {\n    if (!args.entropy) {\n        let payload = Buffer.concat([\n            Buffer.from([CMD.SHARED_CMD_GENERATE_3RD_KEY])\n        ]);\n        let resp = await options.exec(payload);\n        let res = Buffer.from(resp.result, \"hex\");\n\n        return {\"status\": \"ok\", \"publicKey\": res.toString('hex'), \"needsConfirm\": false};\n    } else {\n        let entropyBuf = Buffer.from(args.entropy, \"hex\");\n\n        if (entropyBuf.length !== 32) {\n            throw new HaloLogicError(\"The command.entropy should be exactly 32 bytes, hex encoded.\");\n        }\n\n        let payload = Buffer.concat([\n            Buffer.from([CMD.SHARED_CMD_GENERATE_3RD_KEY]),\n            entropyBuf\n        ]);\n\n        let resp;\n\n        try {\n            resp = await options.exec(payload);\n        } catch (e) {\n            if (e instanceof HaloTagError) {\n                if (e.name === \"ERROR_CODE_INVALID_LENGTH\") {\n                    throw new HaloLogicError(\"The hardened key generation algorithm is not supported with this tag version.\");\n                }\n            }\n\n            throw e;\n        }\n\n        let res = Buffer.from(resp.result, \"hex\");\n\n        if (res.length === 65) {\n            throw new HaloLogicError(\"The hardened key generation algorithm is not supported with this tag version.\");\n        }\n\n        let msg1 = Buffer.from(sha256(res.slice(0, 32)), 'hex');\n        let msg2 = Buffer.from(sha256(res.slice(32, 64)), 'hex');\n        let sig = res.slice(64);\n        let sig1Length = sig[1];\n        let sig1 = sig.slice(0, 2 + sig1Length);\n        let sig2 = sig.slice(2 + sig1Length);\n\n        let candidates = [];\n\n        for (let i = 0; i < 2; i++) {\n            candidates.push(ec.recoverPubKey(msg1, parseSig(sig1), i).encode('hex'));\n            candidates.push(ec.recoverPubKey(msg2, parseSig(sig2), i).encode('hex'));\n        }\n\n        let bestPk = Buffer.from(mode(candidates), 'hex');\n        return {\"status\": \"ok\", \"publicKey\": bestPk.toString('hex'), \"needsConfirm\": true};\n    }\n}\n\nasync function cmdGenKeyConfirm(options, args) {\n    let payload = Buffer.concat([\n        Buffer.from([CMD.SHARED_CMD_GENERATE_3RD_KEY_CONT]),\n        Buffer.from(args.publicKey, \"hex\")\n    ]);\n\n    await options.exec(payload);\n\n    return {\"status\": \"ok\"};\n}\n\nasync function cmdGenKeyFinalize(options, args) {\n    let payload = Buffer.concat([\n        Buffer.from([CMD.SHARED_CMD_GENERATE_3RD_KEY_FINALIZE])\n    ]);\n\n    await options.exec(payload);\n\n    return {\"status\": \"ok\"};\n}\n\nmodule.exports = {\n    cmdSign,\n    cmdSignRandom,\n    cmdWriteLatch,\n    cmdCfgNDEF,\n    cmdGenKey,\n    cmdGenKeyConfirm,\n    cmdGetPkeys,\n    cmdGenKeyFinalize,\n    cmdSignChallenge\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}